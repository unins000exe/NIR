\documentclass[bachelor, och, nir]{SCWorks}
% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа
%    pract      - отчет по практике
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен
\usepackage{subfigure}
\usepackage{tikz,pgfplots}
\pgfplotsset{compat=1.5}
\usepackage{float}

%\usepackage{titlesec}
\setcounter{secnumdepth}{4}
%\titleformat{\paragraph}
%{\normalfont\normalsize}{\theparagraph}{1em}{}
%\titlespacing*{\paragraph}
%{35.5pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\titleformat{\paragraph}[block]
{\hspace{1.25cm}\normalfont}
{\theparagraph}{1ex}{}
\titlespacing{\paragraph}
{0cm}{2ex plus 1ex minus .2ex}{.4ex plus.2ex}

% --------------------------------------------------------------------------%
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\graphicspath{ {./img/} }
\usepackage{tempora}

\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage{listingsutf8}
\usepackage{longtable}
\usepackage{array}
\usepackage[english,russian]{babel}

\usepackage{url}
\usepackage[colorlinks=true, linkcolor=black]{hyperref}

\usepackage{underscore}
\usepackage{setspace}
\usepackage{indentfirst} 
\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{enumitem}
\usepackage{tikz}
\usepackage{textgreek}
\usepackage{slashbox}

\usepackage{minted}
\setminted[python3]{style=bw, linenos, breaklines=true, fontsize=\footnotesize}
\setminted[py]{fontsize=\small, breaklines=true, style=bw, linenos}

\newcommand{\eqdef}{\stackrel {\rm def}{=}}
\newcommand{\specialcell}[2][c]{%
\begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}

\renewcommand\theFancyVerbLine{\small\arabic{FancyVerbLine}}

\newtheorem{lem}{Лемма}

\begin{document}

% Кафедра (в родительном падеже)
\chair{теоретических основ компьютерной безопасности и криптографии}

% Тема работы
\title{Число независимого доминирования и число совершенного геодоминирования}

% Курс
\course{5}

% Группа
\group{531}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
\department{факультета КНиИТ}

% Специальность/направление код - наименование
%\napravlenie{09.03.04 "--- Программная инженерия}
%\napravlenie{010500 "--- Математическое обеспечение и администрирование информационных систем}
%\napravlenie{230100 "--- Информатика и вычислительная техника}
%\napravlenie{231000 "--- Программная инженерия}
\napravlenie{10.05.01 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
% \studenttitle{Студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Стаина Романа Игоревича}

% % Заведующий кафедрой
% \chtitle{д. ф.-м. н., доцент} % степень, звание
% \chname{М.~Б.~Абросимов}

%Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{д. ф.-м. н., доцент} %должность, степень, звание
\saname{М.~Б.~Абросимов}

% Руководитель практики от организации (только для практики,
% для остальных типов работ не используется)
% \patitle{к.ф.-м.н.}
% \paname{С.~В.~Миронов}

% Семестр (только для практики, для остальных
% типов работ не используется)
%\term{8}

% Наименование практики (только для практики, для остальных
% типов работ не используется)
%\practtype{преддипломная}

% Продолжительность практики (количество недель) (только для практики,
% для остальных типов работ не используется)
%\duration{4}

% Даты начала и окончания практики (только для практики, для остальных
% типов работ не используется)
%\practStart{30.04.2019}
%\practFinish{27.05.2019}

% Год выполнения отчета
\date{2024}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам
% (по умолчанию - нумерация сквозная)
% (допускается оба вида нумерации)
% \secNumbering

%-------------------------------------------------------------------------------------------

% \begin{minted}[fontsize=\small]{MySQL}
% \end{minted}

% \begin{figure}[H]
%     \centering
%     \includegraphics[width=0.999\textwidth]{img/}
%     \caption{}
%     \label{easy_hack}
% \end{figure}

\tableofcontents

\intro
Введение

\section{Основные понятия и определения}
% Ссылка на файл Абросимова https://www.sgu.ru/sites/default/files/textdocsfiles/2013/06/26/abrosimov_m.b._dolgov_a.a._prakticheskie_zadaniya_po_grafam.pdf
\textit{Неориентированным графом} (далее графом) называется пара $G = (V, \alpha)$, где $\alpha$ -- симметричное и антирефлексивное отношение на множестве вершин $V$, называемое \textit{отношением смежности}. Если $(u,v) \in \alpha$ , то говорят, что вершины $u$ и $v$ смежны и эти вершины соединены ребром $(u, v)$. При
этом $(u, v)$ и $(v, u)$ это одно и то же ребро, которое обозначают $\{u, v\}$. $V(u)$ -- множество вершин из $V$,
смежных с вершиной $u$ \cite{абросимов2009практические}.

\textit{Степенью} вершины $v$ в неориентированном графе $G$ будем называть количество вершин в $G$, смежных с $v$, и обозначать через $d(v)$.

Множество вершин графа называется \textit{независимым}, если все вершины
этого множества попарно несмежны. Независимое множество называется \textit{максимальным независимым множеством}, если добавление любой вершины графа нарушает свойство независимости. Максимальное число вершин, составляющих независимое множество, называется числом \textit{вершинной независимости}. 

Независимость тесно связана с понятием доминирования. 
\textit{Доминирующее множество} -- это такое подмножество вершин $D \subseteq V$, 
что любая вершина не из $D$ смежна хотя бы одной вершине из $D$. Говорят, 
что вершины $v$ и $u$ доминируют друг друга, если в графе есть ребро $\{v, u\}$ или
$v = u$. 

Если никакая собственная часть доминирующего множества D не
является доминирующим множеством, то множество D называется
\textit{минимальным доминирующим множеством}. 

Доминирующее множество графа минимальной мощности называется
его \textit{наименьшим доминирующим множеством}.

\textit{Число доминирования}
$\gamma(G)$ -- это число вершин в наименьшем
доминирующем множестве графа $G$. 

\textit{Число независимого доминирования} $\gamma_i(G)$ -- это число вершин в
наименьшем независимом доминирующем множестве графа G. Очевидно, 
что $\gamma(G) \leq \gamma_i(G)$.

\textit{Расстоянием} $d(u, v)$ между вершинами $u$ и $v$ называется длина
кратчайшего пути между вершинами $u$ и $v$. Очевидно, что этот путь будет
цепью. Любой путь между вершинами $u$ и $v$ длины $d(u, v)$ называется
\textit{геодезическим}. Говорят, что вершины $u$ и $v$ \textit{геодоминируют} вершины, 
которые лежат на соединяющем их геодезическом пути.

\textit{Геодезическим множеством} графа $G$ называется множество его вершин $S$ такое, 
что каждая вершина графа $G$ принадлежит какой-либо геодезической, соединяющей пару вершин из $S$. 
Геодезическое множество называется \textit{минимальным}, если никакое его собственное подмножество не
является геодезическим множеством. \textit{Геодезическим числом} (или \textit{числом геодоминирования}) $g(G)$ графа $G$
называется минимальная мощность его геодезического множества, а сами
такие множества называются \textit{наименьшими геодезическими множествами}. 

Множество $S$ называется \textit{совершенным геодоминирующим
множеством} графа $G$, если каждая вершина из $V \setminus S$ геодоминируется
только одной парой вершин из $S$. Минимальная мощность совершенного
геодоминирующего множества называется \textit{числом совершенного
геодоминирования} $g_p(G)$. 

\section{Алгоритмы} 
\subsection{Нахождение числа независимого доминирования}
\subsubsection{Необходимые обозначения и обоснование алгоритма}
Итак, число независимого доминирования $\gamma_i(G)$ -- размер наименьшего независимого доминирующего множества,
или, эквивалентно, минимальный размер максимального независимого множества.

В процессе поиска -- на некотором этапе $k$ независимое множество вершин $S_k$ расширяется путем добавления к нему подходящим образом выбранной вершины (чтобы получилось новое независимое множество $S_{k+1}$) на этапе $k+1$, и так поступают до тех пор, пока добавление вершин станет невозможным, а порожденное множество не станет максимально независимым множеством. Пусть $Q_k$ будет на этапе $k$ наибольшим множеством вершин, для которого $S_k \cap Q_k= \varnothing$, то есть после добавления любой вершины из $Q_k$ в $S_k$ получится независимое множество $S_{k+1}$. В некоторый произвольный момент работы алгоритма множество $Q_k$ состоит из вершин двух типов: подмножества $Q_k^-$ тех вершин, которые уже использовались в процессе поиска для расширения множества $S_k$, и подмножества $Q_k^+$ таких вершин, которые ещё не использовались. Тогда дальнейшее ветвление в дереве поиска включает процедуру выбора вершины $x_{ik} \in Q_k^+$, добавления её к $S_k$
\[ S_{k + 1} = S_k \cup \{x_{ik}\} \]
и порождения новых множеств

\[ Q_{k +1 }^- = Q_k^- \setminus V(x_{ik});  \]
\[ Q_{k + 1}^+ = Q_k^+ \setminus (V(x_{ik}) \cup \{x_{ik}\}). \]

Шаг возвращения алгоритма состоит в удалении вершины $x_{ik}$ из $S_{k+1}$, чтобы вернуться к $S_k$, изъятии $x_{ik}$ из старого множества $Q_k^+$ и добавлении $x_{ik}$ к старому множеству $Q_k^-$  для формирования новых множеств $Q_k^-$ и $Q_k^+$.
Множество $S_k$ является максимально независимым множеством только тогда, когда невозможно его дальнейшее расширение, то есть когда $Q_k^+=\varnothing$. Если $Q_k^- = \varnothing$, то текущее множество $S_k$ было расширено на некотором предшествующем этапе работы алгоритма путем добавления вершины из $Q_k^-$, и поэтому не является максимально независимым множеством. Таким образом, необходимым и достаточным условием того, что $S_k$ -- максимально независимое множество, является выполнение равенств:
\[ Q_k^+ = Q_k^- = \varnothing. \]

Если очередной этап работы алгоритма наступает тогда, когда существует некоторая вершина $x \in Q_k^-$, для которой $V(x) \cap Q_k^+ = \varnothing$, то безразлично, какая из вершин, принадлежащих $Q_k^+$, использовалась для расширения $S_k$, и это справедливо при любом числе дальнейших ветвлений. Вершина $x$ не может быть удалена из $Q_p^-$ на любом следующем шаге $p > k$. Таким образом, существование $x$, такого что 
\[ x \in Q_k^- \text{ и } V(x) \cap Q_k^+ = \varnothing \quad \eqno(*) \]
является достаточным для осуществления шага возвращения, потому что из $S_k$ 
при всяком дальнейшем ветвлении уже не получится максимально независимое множество.

Если $k=0$, то возвращение выполнить невозможно, поэтому при $k=0$ осуществляется переход на прямой шаг.

\subsubsection{Алгоритм нахождения числа независимого доминирования}

\textit{Начальная установка}.

\underline{Шаг 1}. Пусть $S_0 = Q_0^- = \varnothing$, $Q_0^+ = X, k = 0$.

\textit{Прямой шаг}.

\underline{Шаг 2}. Выбрать вершину $x_{ik} \in Q_k^+$ и сформировать $S_{k + 1}$, $Q_{k + 1}^-$ и $Q_{k + 1}^+$,
оставив $Q_k^-$ и $Q_k^+$ нетронутыми. Положить $k = k + 1$.

\textit{Проверка}.

\underline{Шаг 3}. Если выполняется условие $(*)$, то перейти к шагу 5, иначе к шагу 4.

\underline{Шаг 4}. Если $Q_k^+ = Q_k^- = \varnothing$, то сохранить максимальное независимое множество $S_k$ и перейти к шагу 5. Если $Q_k^+ = \varnothing$, а $Q_k^- \neq \varnothing $, то перейти к шагу 5, иначе -- к шагу 2.

\textit{Шаг возвращения}.

\underline{Шаг 5}. Положить $k = k - 1$. Удалить $x_{ik}$ из $S_{k+1}$, чтобы получить $S_k$. Исправить $Q_k^+$ и $Q_k^-$, удалив вершину $x_{ik}$ из $Q_k^+$  и добавив ее к $Q_k^-$. Если $k \neq 0$, то перейти к шагу 3, иначе если $Q_0^+ = \varnothing$, то остановиться (к этому моменту будут сохранены все максимальные независимые множества), иначе перейти к шагу 2.

\textit{Результат}.

\underline{Шаг 6}. Найти среди сохранённых максимальных независимых множеств $S_k$-ых то, у которого
мощность меньше остальных. Вернуть её как результат.

\subsection{Нахождение числа совершенного геодоминирования}
Алгоритм нахождения числа совершенного геодоминирования представляет собой 
перебор неповторяющихся подмножеств вершин $S$ множества $V = \{x_0, x_1, \dots, x_n\}$ до тех пор, пока
какое-либо из этих множеств не удовлетворит определению \textit{совершенного 
геодоминирующего множества} (то есть каждое такое $S$ рассматривается как 
потенциальное совершенное геодоминирующее множество). 

% Добавить определение степени вершины
Стоит отметить, что перебор можно ускорить, если к таким подмножествам $S$ 
добавлять вершины, степень которых равна 1. Это обусловлено тем, что такие вершины не будут
находиться на пути между двумя другими отличными вершинами. Обозначим множество
таких вершин $B$.

Так же в алгоритме используется вспомогательная матрица $M$, в которой сохраняются
все кратчайшие пути между каждой парой вершин из $V$. Это необходимо, чтобы не считать
кратчайший путь между вершинами несколько раз.

Проверка на соответствие $S$ совершенному геодоминирующему множеству
выполняется следующим образом. Находятся все геодезические (или кратчайшие) пути $P_0, P_1, \dots, P_l$ между вершинами из $S$.
Далее возможны три варианта:
\begin{enumerate}
    \item Если $\exists \, x \in V \setminus S: \forall \, P_i \; x \notin P_i, \, 0 \leq i \leq l$, то есть найдётся вершина $x$ из $V \setminus S$ не встретилась ни на одном из геодезических путей,
    значит, что $S$ не геодоминирующее множество.
    \item Если $\exists \, x \in V \setminus S: x \in P_i \wedge \dots \wedge x \in P_j, \, i, j \in 0, \dots, l$, то есть найдётся вершина $x$ из $V \setminus S$ находится на нескольких геодезических путях, то
    эта вершина геодоминируется несколькими парами вершин из $S$, то есть $S$ не совершенное геодоминирующее
    множество. 
    \item Если $\forall \, x \in V \setminus S: \exists \, \text{единственный геодезический путь } P: x \in P$, то есть каждая вершина из $V \setminus S$ принадлежит единственному геодезическому пути, то $S$ \underline{совершенное геодоминирующее множество}.
\end{enumerate}

Далее, поскольку перебор возможных совершенных геодоминирующих множеств начинается с множеств минимальной длины, мощность первого подходящего множества окажется \underline{числом совершенного} \\
\underline{геодоминирования}.

\subsubsection{Алгоритм нахождения числа совершенного геодоминирования}

\underline{Шаг 1}. Построить множество $B$ вершин степени 1. 
Пусть $k = 2 - |B|$. Если $k < 0$, то $k = 0$. 

\underline{Шаг 2}. Вычислить следующее сочетание вершин без повторений $C$ длиной $k$ из множества
$V \setminus B$ и добавить к нему $B$. В итоге $S = B \cup C$.

\underline{Шаг 3}. Пусть $P = \varnothing$.

\underline{Шаг 4}. Для каждой пары вершин $x_i, x_j$ из $S$: если в $M_{ij}$ не сохранёны пути между вершинами
$x_i$ и $x_j$ $P_0, \dots, P_l$, то вычислить их. Затем добавить к $P$ -- $P = P_0 \cup \dots \cup P_l$ эти пути без начальных и конечных вершин (то есть $x_i$ и $x_j$).

\underline{Шаг 5}. Если $P = \varnothing$, то $k = k + 1$ и вернуться к шагу 2.

\underline{Шаг 6}. Для каждой вершины из $V \setminus S$ проверяется, что она встречается
в $P$ всего 1 раз. Если это не так, то $k = k + 1$ и вернуться к шагу 2. Иначе $S$ --
совершенное геодоминирующее множество. Вернуть $|S|$ в качестве результата.

\section{Исследование числа независимого доминирования и совершенного геодоминирования}
\subsection{Использованные средства}
% Ссылка на nauty https://pallini.di.uniroma1.it/
\subsection{Пакет nauty and Traces}
Для исследований был использован open-source пакет nauty and Traces, 
содержащий набор программ gtools. Gtools предназначен для генерации 
графов в форматах graph6 и sparse6, подсчёта их количества автоморфизмов 
и раскрасок.

Программа geng из этого набора была использована для генерации всех 
неизоморфных неориентированных связных графов с числом вершин до 11.
При генерации использовался ключ <<-c>>, чтобы генерировать только связные графы.

Формат graph6 является текстовым форматом для представления графов. Он используется для компактного представления неориентированных графов без петель. Формат graph6 используется для хранения и передачи графов в компьютерных программах и системах.

% https://users.cecs.anu.edu.au/~bdm/data/formats.txt
Опишем формат graph6. Пусть $n$ -- число вершин графа $G$. Число $n$ может находиться в диапазоне от $0$ до $2^{36} - 1$. Рассмотрим только тот случай, когда $1 \leq n \leq 62$. 

Граф представляется в виде $N(n) \; R(x)$ следующим образом:
\begin{enumerate}
    \item $N(n) = n + 63$.
    \item Верхний треугольник без диагонали
    матрицы смежности графа $G$ записывается в виде битового вектора $x$ длины $\frac{n (n - 1)}{2}$ в порядке:
    $(0,1),(0,2),\\(1,2),(0,3),(1,3),(2,3),...,(n-2,n-1)$. 
    \item Вектор $x$ дополняется справа нулями, пока его длина не будет кратна 6.
    \item Вектор $x$ делится на группы по 6 бит в каждой. К каждой группе прибавляется 63. 
    \item Затем эти значения сохраняются по одному на байт. В итоге получаем представление $R(x)$ битового вектора $x$.
\end{enumerate}
Таким образом получаем граф в формате graph6, где каждый байт представляется ASCII символом.

Например, пусть $n = 5$, $G$ содержит рёбра $0-2$, $0-4$, $1-3$ и $3-4$.
Тогда $x = 0 \; 10 \; 010 \; 1001$, $N(n) = N(5) = 68$ и $R(x)$ = $R(010010 \; 100100) = 81 \; 99$.
Следовательно, граф будет иметь представление $68 \; 81 \; 99$.

\subsubsection{Среда Cygwin}
% https://cygwin.com/
Запуск генератора графов geng и реализованной производился в UNIX-подобной среде Cygwin.
Это большая коллекция инструментов GNU с открытым исходным кодом, которые обеспечивают функциональность, аналогичную дистрибутиву Linux для Windows.

\subsubsection{Описание реализованной программы}
В ходе работы была написана программа на языке Python.
Данная программа реализует алгоритмы из раздела 2.

% https://networkx.org/
На вход программы из генератора графов geng поступает список графов в формате graph6. 
С помощью библиотеки графы в формате graph6 конвертируются в объект класса Graph. 
Далее графы из этого списка распределяются между процессами. Для каждого графа вычисляются искомые инварианты.
На выходе программы текстовый файл, содержащий список графов в формате graph6 и соответствующие им инварианты (сначала число совершенного геодоминирования $g_p$, затем через запятую число независимого доминирования $\gamma_i$). Внизу текстового файла записывается таблица с количеством графов, имеющих заданные $g_p$ и $\gamma_i$. На рисунке \ref{img:outfile} изображён пример выходного файла для графов, с числом вершин 5.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.32\textwidth]{outfile.png}
    \caption{Пример выходного файла}
    \label{img:outfile}
\end{figure}

\subsubsection{Аппаратные средства}
Вычисления производились на персональном компьютере со следующими характеристиками:
\begin{itemize}
    \item Операционная система: Windows 10.
    \item Процессор Intel(R) Core(TM) i5-6400 CPU 2.70 ГГц (4 ядра).
    \item Оперативная память: 16 ГБ.
    \item Тип системы: x64.
\end{itemize}


\subsection{Результаты исследования}
На таблице \ref{tab:time} можно увидеть, как соотносятся число вершин и число графов к времени работы программы.
Начиная с 9-вершинных графов время работы увеличивается примерно на 2 порядка.

\begin{table}[H]
    \begin{tabular}{|c|c|c|}
    \hline
    Число вершин & Число графов & Время работы \\ \hline
    1  & 1 & 1.18 с \\ \hline
    2  & 1 & 1.18 с \\ \hline
    3  & 2 & 1.21 с \\ \hline
    4  & 6 & 1.22 с \\ \hline
    5  & 21 & 1.28 с\\ \hline
    6  & 112 & 1.3 с \\ \hline
    7  & 853 & 1.45 с \\ \hline
    8  & 11117 & 5.62 с \\ \hline
    9  & 261080 & 3.37 мин \\ \hline
    10 & 11716571 & 4.73 ч \\ \hline
    11 & 1006700565 & 30 дней \\ \hline
    \end{tabular}
    \caption{Время работы программы}
    \label{tab:time}
\end{table}

На следующих таблицах отражены полученные в ходе вычислений результаты
для графов до 11 вершин.

\begin{table}[H]
    \begin{tabular}{|c|c|}
    \hline
    \backslashbox[1pt]{$g_p$}{$\gamma_i$} & 1 \\ \hline
    2                                     & 1 \\ \hline
    \end{tabular}
    \caption{Количество 2-вершинных графов, имеющих заданные $g_p$ и $\gamma_i$}
\end{table}

\begin{table}[H]
    \begin{tabular}{|c|c|}
    \hline
    \backslashbox[1pt]{$g_p$}{$\gamma_i$} & 1  \\ \hline
    2                                     & 1  \\ \hline
    3                                     & 1  \\ \hline
    \end{tabular}
    \caption{Количество 3-вершинных графов, имеющих заданные $g_p$ и $\gamma_i$}
\end{table}

\begin{table}[H]
    \begin{tabular}{|c|c|c|}
    \hline
    \backslashbox[1pt]{$g_p$}{$\gamma_i$} & 1 & 2 \\ \hline
    2                                     & 1 & 2 \\ \hline
    3                                     & 0 & 0 \\ \hline
    4                                     & 3 & 0 \\ \hline
    \end{tabular}
    \caption{Количество 4-вершинных графов, имеющих заданные $g_p$ и $\gamma_i$}
\end{table}

\begin{table}[H]
    \begin{tabular}{|c|c|c|}
    \hline
    \backslashbox[1pt]{$g_p$}{$\gamma_i$} & 1 & 2 \\ \hline
    2                                     & 2 & 3 \\ \hline
    3                                     & 0 & 2 \\ \hline
    4                                     & 2 & 1 \\ \hline
    5                                     & 7 & 4 \\ \hline
    \end{tabular}
    \caption{Количество 5-вершинных графов, имеющих заданные $g_p$ и $\gamma_i$}
\end{table}

\begin{table}[H]
    \begin{tabular}{|c|c|c|c|}
    \hline
    \backslashbox[1pt]{$g_p$}{$\gamma_i$} & 1 & 2 & 3  \\ \hline
    2                                     & 4 & 11 & 0  \\ \hline
    3                                     & 0 & 8 & 0  \\ \hline
    4                                     & 8 & 14 & 0  \\ \hline
    5                                     & 7 & 11 & 0  \\ \hline
    6                                     & 15 & 28 & 4  \\ \hline
    \end{tabular}
    \caption{Количество 6-вершинных графов, имеющих заданные $g_p$ и $\gamma_i$}
\end{table}

\begin{table}[H]
    \begin{tabular}{|c|c|c|c|}
    \hline \backslashbox[1pt]{$g_p$}{$\gamma_i$} 
      & 1 & 2 & 3     \\ \hline
    2 & 11 & 23 & 1    \\ \hline
    3 & 0 & 70 & 2    \\ \hline
    4 & 24 & 122 & 8   \\ \hline
    5 & 53 & 108 & 17  \\ \hline
    6 & 26 & 100 & 14 \\ \hline
    7 & 42 & 192 & 40 \\ \hline
    \end{tabular}
    \caption{Количество 7-вершинных графов, имеющих заданные $g_p$ и $\gamma_i$}
\end{table}

\begin{table}[H]
    \begin{tabular}{|c|c|c|c|c|}
    \hline \backslashbox[1pt]{$g_p$}{$\gamma_i$} 
      & 1  & 2   & 3  & 4 \\ \hline
    2 & 34 & 137  & 5  & 0    \\ \hline
    3 & 0  & 581  & 4  & 0    \\ \hline
    4 & 126 & 1638 & 107 & 2  \\ \hline
    5 & 314 & 1489 & 238 & 1  \\ \hline
    6 & 283 & 1467 & 314 & 4  \\ \hline
    7 & 145 & 1249 & 350 & 0  \\ \hline
    8 & 142 & 1865 & 601 & 21 \\ \hline
    \end{tabular}
    \caption{Количество 8-вершинных графов, имеющих заданные $g_p$ и $\gamma_i$}
\end{table}

\begin{table}[H]
    \begin{tabular}{|c|c|c|c|c|c|}
    \hline \backslashbox[1pt]{$g_p$}{$\gamma_i$} 
      & 1  & 2   & 3  & 4 & 5           \\ \hline
    2 & 156 & 888  & 1  & 0 & 0        \\ \hline
    3 & 0  & 8002  & 182  & 0 & 0      \\ \hline
    4 & 861 & 31921 & 1853 & 13 & 0    \\ \hline
    5 & 3422 & 38055 & 6310 & 27 & 0   \\ \hline
    6 & 3477 & 33948 & 7715 & 66 & 0   \\ \hline
    7 & 2461 & 29432 & 9134 & 144 & 0  \\ \hline
    8 & 1210 & 25377 & 10380 & 184 & 0 \\ \hline
    9 & 759 & 31055 & 13511 & 535 & 1  \\ \hline
    \end{tabular}
    \caption{Количество 9-вершинных графов, имеющих заданные $g_p$ и $\gamma_i$}
\end{table}

\begin{table}[H]
    \begin{tabular}{|c|c|c|c|c|c|}
    \hline \backslashbox[1pt]{$g_p$}{$\gamma_i$} 
      & 1 & 2 & 3 & 4 & 5 \\ \hline
    2 & 1044 & 11456 & 7 & 4 & 0 \\ \hline
    3 & 0 & 189606 & 4209 & 1 & 0 \\ \hline
    4 & 10658 & 998277 & 69100 & 281 & 4 \\ \hline
    5 & 56296 & 1607983 & 274765 & 639 & 0 \\ \hline
    6 & 81435 & 1586103 & 388261 & 2498 & 5 \\ \hline
    7 & 60293 & 1222947 & 385507 & 4654 & 8 \\ \hline
    8 & 37819 & 1036069 & 434625 & 9015 & 28 \\ \hline
    9 & 18948 & 1004799 & 495269 & 13250 & 0 \\ \hline
    10 & 8175 & 1105022 & 575185 & 22158 & 168 \\ \hline
    \end{tabular}
    \caption{Количество 10-вершинных графов, имеющих заданные $g_p$ и $\gamma_i$}
\end{table}

\begin{table}[H]
    \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline \backslashbox[1pt]{$g_p$}{$\gamma_i$} 
    & 1 & 2 & 3 & 4 & 5 & 6 \\ \hline
    2 & 12346   & 262322    & 66       & 9       & 0     & 0 \\ \hline
    3 & 699     & 8237385   & 315318   & 288     & 0     & 0 \\ \hline
    4 & 242749  & 52602584  & 4781780  & 11974   & 51    & 0 \\ \hline
    5 & 1636063 & 110808715 & 22172688 & 44650   & 56    & 0 \\ \hline
    6 & 3216573 & 129754442 & 36050965 & 152111  & 124   & 0 \\ \hline
    7 & 2839470 & 100490898 & 34970157 & 307986  & 387   & 0 \\ \hline
    8 & 1830607 & 74502192  & 33823940 & 523234  & 1027  & 1 \\ \hline
    9 & 1196547 & 73676844  & 38671436 & 854752  & 2438  & 0 \\ \hline
    10 & 727558  & 81534788  & 38182632 & 1192088 & 3404  & 0 \\ \hline
    11 & 302556  & 97320312  & 51779224 & 1650914 & 11205 & 10 \\ \hline
    \end{tabular}
    \caption{Количество 11-вершинных графов, имеющих заданные $g_p$ и $\gamma_i$}
\end{table}

\subsection{Построение гипотез}
Гипотезы

\conclusion
Заключение

\bibliographystyle{gost780uv}
\inputencoding{cp1251}
\bibliography{thesis}
\inputencoding{utf8}

\appendix

\section{Каталог графов}

    \section{Листинг \texttt{main.py}}
    % \inputminted{python3}{multi_main.py}
    \begin{minted}[]{python3}
# число независимого доминирования и число совершенного геодоминирования
from sys import stdin
import networkx as nx
import time
from itertools import combinations
import multiprocessing as mp


def find_maximal_independent_sets(g):
    # 1 Начальная установка
    k, s, q_minus, q_plus = 0, [], [[]], [list(g.nodes)]
    result = []

    def step2(k):
        xk = q_plus[k][0]
        s.append(xk)
        if k >= len(q_minus) - 1:
            q_minus.append([])
        else:
            q_minus[k + 1] = list(set(q_minus[k]) - set(g.adj[xk]))
        t_plus_k = q_plus[k].copy()
        t_plus_k.remove(xk)
        if k >= len(q_plus) - 1:
            q_plus.append(list(set(t_plus_k) - set(g.adj[xk])))
        else:
            q_plus[k + 1] = list(set(t_plus_k) - set(g.adj[xk]))
        k += 1
        # print(f'Шаг 2 \nk = {k}, xk = {xk} \nS = {s} \nQ+ = {q_plus} \nQ- = {q_minus}')
        return xk, k

    def step5(s, k):
        k -= 1
        xk = s[k]
        s.pop()
        q_plus[k].remove(xk)
        q_minus[k].append(xk)
        # print(f'Шаг 5 \nk = {k}, xk = {xk} \nS = {s} \nQ+ = {q_plus} \nQ- = {q_minus}')
        return k

    while len(q_plus[0]) != 0:
        if k != 0:
            # 3 Проверка
            if xk in q_minus and set(g.adj[xk]) & set(q_plus[k]) == set():
                k = step5(s, k)
            else:
                # 4
                if len(q_plus[k]) == 0:
                    if len(q_minus[k]) == 0:
                        # print('=' * 40)
                        # print(f'{s} к результату')
                        result.append(s.copy())
                        # print('=' * 40)
                        k = step5(s, k)
                    else:
                        k = step5(s, k)
                else:
                    xk, k = step2(k)
        else:
            xk, k = step2(k)
    return result


def independent_domination_number(g):
    g6 = g[0:-1]
    g = nx.from_graph6_bytes(g[0:-1].encode())
    maximal_independent_sets = find_maximal_independent_sets(g)
    maximal_independent_sets.sort(key=len)
    for s in maximal_independent_sets:
        if nx.is_dominating_set(g, s):
            return g6, len(s)


def find_perfect_geodominating_sets(g):
    g6 = g[0:-1]
    g = nx.from_graph6_bytes(g[0:-1].encode())
    nodes = set(g.nodes)
    num_nodes = len(nodes)
    all_paths = [[None] * num_nodes for _ in range(num_nodes)]

    base_s = set()
    for node in nodes:
        if g.degree[node] == 1:
            base_s.add(node)
    nodes = nodes - base_s

    for k in range(1, len(nodes)):
        # Всевозможные варианты множества вершин S
        for si in combinations(nodes, k):
            s = set(si).union(base_s)
            v = nodes - s
            # print('S =', si)
            # print('V\\S =', v)

            paths = []
            # Всевозможные кратчайшие пути между вершинами из S
            for a, b in combinations(s, 2):
                if all_paths[a][b] is None:
                    all_paths[a][b] = list(nx.all_shortest_paths(g, a, b))
                for p in all_paths[a][b]:
                    paths += p[1:-1]

            # print('Пути', paths)
            if len(paths) == 0:
                continue

            flag = True
            for node in v:
                count = paths.count(node)
                # Если какая-то вершина из V\S встречается больше одного раза, значит
                # она геодоминируется несколькими парами вершин из S. Или вершина не геод-ся вовсе
                if count != 1:
                    # print('No', si)
                    flag = False
                    break

            if flag:
                # print('S', si)
                # print('V\\S', v)
                return g6, len(si)
    # Если не получилось найти, значит в S должны быть все вершины
    # print('S', nodes)
    return g6, num_nodes


if __name__ == '__main__':
    graphs6 = stdin.readlines()
    graphs6 = graphs6[len(graphs6) // 2:]
    t0 = time.time()
    g = nx.from_graph6_bytes(graphs6[0][0:-1].encode())
    num_nodes = len(g.nodes)
    f_name = 'res' + str(num_nodes) + '.txt'
    res_file = open(f_name, 'a')
    res_file.truncate(0)

    agents = mp.cpu_count()
    chunksize = 1
    with mp.Pool(processes=agents) as pool:
        result = pool.map(find_perfect_geodominating_sets, graphs6, chunksize)
        result2 = pool.map(independent_domination_number, graphs6, chunksize)

    table = [[0] * num_nodes for _ in range(num_nodes)]
    for a, b in zip(result, result2):
        table[a[1] - 1][b[1] - 1] += 1
        # Первое число геодоминирования, второе доминирования
        res_file.write(a[0] + str(a[1]) + ',' + str(b[1]) + '\n')

    for row in table:
        res_file.write(str(row) + '\n')

    print(f'Время работы: {time.time() - t0} сек.')
    res_file.close()

    \end{minted}

\end{document}